trigger: none
  # branches:
  #   include:
  #     - CICDSetup  # Trigger pipeline on commits to the main branch

pool:
  vmImage: 'windows-latest'  # Use Windows-based agent to run PowerShell scripts and Power BI Desktop

variables:
  artifact_path: '$(Build.ArtifactStagingDirectory)'  # Path where build artifacts will be stored
  deployment_env: 'Dev'  # Change to 'UAT' as needed
  config_file: 'Visa/config.json'  # Updated path to match your folder structure

jobs:
- job: DeployPowerBIReports
  displayName: 'Deploy Power BI Reports'
  steps:
    # Step 1: Install .NET SDK (if required by your PowerShell Core scripts)
    - task: UseDotNet@2
      displayName: 'Install .NET SDK'
      inputs:
        packageType: 'sdk'
        version: '5.x'  # Make sure your PowerShell Core uses the appropriate version

    # Step 2: Install Power BI Desktop (Simplified Version)
    - task: PowerShell@2
      displayName: 'Install Power BI Desktop'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Installing Power BI Desktop via Chocolatey..."
          
          # Install Chocolatey if not present
          if (-not (Get-Command choco -ErrorAction SilentlyContinue)) {
              Write-Host "Installing Chocolatey..."
              [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
              iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
          }
          
          # Install Power BI Desktop
          try {
              choco install powerbi --yes --force --ignore-checksums
              Write-Host "Chocolatey installation completed."
          } catch {
              Write-Warning "Chocolatey installation had issues: $_"
              
              # Fallback: Direct download method
              Write-Host "Attempting direct download method as fallback..."
              try {
                  $installerUrl = "https://download.microsoft.com/download/8/8/0/880BCA75-79DD-466A-927D-1ABF1F5454B0/PBIDesktopSetup_x64.exe"
                  $installerPath = "$env:TEMP\PBIDesktopSetup.exe"
                  
                  # Clean up any existing installer
                  if (Test-Path $installerPath) {
                      Remove-Item $installerPath -Force
                  }
                  
                  Write-Host "Downloading Power BI Desktop from: $installerUrl"
                  
                  # Download with better error handling
                  $webClient = New-Object System.Net.WebClient
                  $webClient.Headers.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")
                  $webClient.DownloadFile($installerUrl, $installerPath)
                  
                  # Verify download
                  if (-not (Test-Path $installerPath)) {
                      throw "Download failed - file not found"
                  }
                  
                  $fileSize = (Get-Item $installerPath).Length
                  Write-Host "Downloaded file size: $([math]::Round($fileSize/1MB, 2)) MB"
                  
                  if ($fileSize -lt 10MB) {
                      throw "Downloaded file appears to be corrupt"
                  }
                  
                  Write-Host "Starting installation..."
                  
                  # Install Power BI Desktop
                  $process = Start-Process -FilePath $installerPath -ArgumentList "/quiet", "/norestart" -PassThru -Wait
                  
                  if ($process.ExitCode -ne 0) {
                      Write-Warning "Installation process returned exit code: $($process.ExitCode)"
                  } else {
                      Write-Host "Installation process completed successfully."
                  }
                  
                  # Clean up installer
                  if (Test-Path $installerPath) {
                      Remove-Item $installerPath -Force -ErrorAction SilentlyContinue
                  }
                  
              } catch {
                  Write-Warning "Direct download also failed: $_"
                  Write-Host "Attempting winget installation..."
                  
                  try {
                      winget install --id Microsoft.PowerBI --silent --accept-package-agreements --accept-source-agreements
                      Write-Host "Winget installation completed."
                  } catch {
                      Write-Warning "All installation methods attempted. Continuing with pipeline..."
                  }
              }
          }
          
          Write-Host "Power BI Desktop installation process completed. Pipeline will continue."
        continueOnError: true

    # Step 3: Install PowerShell Modules (Fixed execution policy issue)
    - task: PowerShell@2
      displayName: 'Install Required PowerShell Modules'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Installing required PowerShell modules..."
          
          # Use -Force and -SkipPublisherCheck to bypass execution policy restrictions
          $modules = @('MicrosoftPowerBIMgmt')
          
          foreach ($module in $modules) {
              Write-Host "Installing module: $module"
              try {
                  # Install module with additional flags to bypass restrictions
                  Install-Module -Name $module -Force -AllowClobber -Scope CurrentUser -SkipPublisherCheck -Repository PSGallery
                  Import-Module -Name $module -Force
                  Write-Host "✓ Module $module installed successfully"
                  
                  # Verify the module is available
                  $moduleInfo = Get-Module -Name $module -ListAvailable
                  if ($moduleInfo) {
                      Write-Host "  Module version: $($moduleInfo.Version)"
                  }
              } catch {
                  Write-Warning "Failed to install $module : $_"
                  
                  # Try alternative installation method
                  Write-Host "Attempting alternative installation for $module..."
                  try {
                      # Use PowerShellGet with TLS 1.2
                      [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
                      Install-PackageProvider -Name NuGet -MinimumVersion 2.8.5.201 -Force -Scope CurrentUser
                      Install-Module -Name $module -Force -AllowClobber -Scope CurrentUser -Repository PSGallery -Confirm:$false
                      Import-Module -Name $module -Force
                      Write-Host "✓ Alternative installation successful for $module"
                  } catch {
                      Write-Error "All installation methods failed for $module : $_"
                  }
              }
          }
          
          # List all installed modules for verification
          Write-Host "`nInstalled PowerShell modules:"
          Get-Module -ListAvailable | Where-Object { $_.Name -like "*PowerBI*" } | Format-Table Name, Version, ModuleBase -AutoSize
        pwsh: true
        errorActionPreference: 'continue'  # Continue on errors

    # Step 4: Debug - List files to verify structure
    - task: PowerShell@2
      displayName: 'Debug - List Repository Structure'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "=== Repository Structure Debug ==="
          Write-Host "Build Sources Directory: $(Build.SourcesDirectory)"
          Write-Host "Current Location: $(Get-Location)"
          
          Write-Host "`n=== Root Directory Contents ==="
          Get-ChildItem -Path "$(Build.SourcesDirectory)" -Force | Format-Table Name, PSIsContainer, Length -AutoSize
          
          Write-Host "`n=== Looking for Visa folder ==="
          $visaPath = "$(Build.SourcesDirectory)\Visa"
          if (Test-Path $visaPath) {
              Write-Host "✓ Visa folder found at: $visaPath"
              Get-ChildItem -Path $visaPath -Force | Format-Table Name, PSIsContainer, Length -AutoSize
              
              Write-Host "`n=== Looking for Scripts folder ==="
              $scriptsPath = "$visaPath\Scripts"
              if (Test-Path $scriptsPath) {
                  Write-Host "✓ Scripts folder found at: $scriptsPath"
                  Get-ChildItem -Path $scriptsPath -Force | Format-Table Name, PSIsContainer, Length -AutoSize
              } else {
                  Write-Warning "✗ Scripts folder not found at: $scriptsPath"
              }
              
              Write-Host "`n=== Looking for Config file ==="
              $configPath = "$visaPath\config.json"
              if (Test-Path $configPath) {
                  Write-Host "✓ Config file found at: $configPath"
              } else {
                  Write-Warning "✗ Config file not found at: $configPath"
              }
          } else {
              Write-Warning "✗ Visa folder not found at: $visaPath"
              Write-Host "`nSearching for PowerShell files recursively..."
              Get-ChildItem -Path "$(Build.SourcesDirectory)" -Recurse -Filter "*.ps1" | Format-Table FullName -AutoSize
          }
        pwsh: true
        continueOnError: true

    # Step 5: Run the PowerShell script to convert PBIP to PBIX and deploy the reports
    - task: PowerShell@2
      displayName: 'Run PowerShell Script to Deploy Reports'
      inputs:
        targetType: 'inline'
        script: |
          # Define paths
          $buildSourcesDir = "$(Build.SourcesDirectory)"
          $scriptPath = "$buildSourcesDir\Visa\Scripts\MainOrchestrator.ps1"
          $configPath = "$buildSourcesDir\Visa\config.json"
          
          Write-Host "=== Deployment Script Execution ==="
          Write-Host "Build Sources Directory: $buildSourcesDir"
          Write-Host "Script Path: $scriptPath"
          Write-Host "Config Path: $configPath"
          Write-Host "Workspace: $(deployment_env)"
          
          # Verify files exist before execution
          if (-not (Test-Path $scriptPath)) {
              Write-Error "Script file not found: $scriptPath"
              
              # Try to find the script in alternative locations
              Write-Host "Searching for MainOrchestrator.ps1 in repository..."
              $foundScripts = Get-ChildItem -Path $buildSourcesDir -Recurse -Filter "MainOrchestrator.ps1" -ErrorAction SilentlyContinue
              
              if ($foundScripts) {
                  Write-Host "Found MainOrchestrator.ps1 files at:"
                  foreach ($script in $foundScripts) {
                      Write-Host "  - $($script.FullName)"
                  }
                  
                  # Use the first found script
                  $scriptPath = $foundScripts[0].FullName
                  Write-Host "Using script at: $scriptPath"
              } else {
                  throw "MainOrchestrator.ps1 not found anywhere in the repository"
              }
          }
          
          if (-not (Test-Path $configPath)) {
              Write-Error "Config file not found: $configPath"
              
              # Try to find the config in alternative locations
              Write-Host "Searching for config.json in repository..."
              $foundConfigs = Get-ChildItem -Path $buildSourcesDir -Recurse -Filter "config.json" -ErrorAction SilentlyContinue
              
              if ($foundConfigs) {
                  Write-Host "Found config.json files at:"
                  foreach ($config in $foundConfigs) {
                      Write-Host "  - $($config.FullName)"
                  }
                  
                  # Use the first found config
                  $configPath = $foundConfigs[0].FullName
                  Write-Host "Using config at: $configPath"
              } else {
                  throw "config.json not found anywhere in the repository"
              }
          }
          
          # Change to script directory
          $scriptDir = Split-Path $scriptPath -Parent
          Set-Location $scriptDir
          Write-Host "Changed working directory to: $scriptDir"
          
          # Execute the script
          Write-Host "`n=== Executing Deployment Script ==="
          try {
              & $scriptPath -Workspace "$(deployment_env)" -ConfigFile $configPath
              Write-Host "✓ Script execution completed successfully"
          } catch {
              Write-Error "✗ Script execution failed: $_"
              throw
          }
        pwsh: true  # Use PowerShell Core (pwsh)
        workingDirectory: '$(Build.SourcesDirectory)'  # Set the script working directory to root of the repository
        errorActionPreference: 'stop'  # Stop on errors for the main script

    # Step 6: Publish build artifacts (optional step, if you want to store outputs like PBIX files)
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Artifacts'
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)'  # Path to artifacts
        ArtifactName: 'drop'  # Name of the artifact
        publishLocation: 'Container'