trigger: none

pool:
  vmImage: 'windows-latest'

variables:
  artifact_path: '$(Build.ArtifactStagingDirectory)'
  deployment_env: 'Dev'

jobs:
- job: DeployPowerBIReports
  displayName: 'Deploy Power BI Reports'
  steps:
    # Step 1: Install .NET SDK
    - task: UseDotNet@2
      displayName: 'Install .NET SDK'
      inputs:
        packageType: 'sdk'
        version: '5.x'

    # Step 2: Install Power BI Desktop
    - task: PowerShell@2
      displayName: 'Install Power BI Desktop'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Installing Power BI Desktop via winget (fastest method)..."
          try {
              winget install --id Microsoft.PowerBI --silent --accept-package-agreements --accept-source-agreements
              Write-Host "✓ Power BI Desktop installed successfully"
          } catch {
              Write-Warning "Winget installation failed, continuing without Power BI Desktop: $_"
          }
        continueOnError: true

    # Step 3: Install PowerShell Modules
    - task: PowerShell@2
      displayName: 'Install Required PowerShell Modules'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Installing required PowerShell modules..."
          $modules = @('MicrosoftPowerBIMgmt')
          
          foreach ($module in $modules) {
              Write-Host "Installing module: $module"
              try {
                  Install-Module -Name $module -Force -AllowClobber -Scope CurrentUser -SkipPublisherCheck -Repository PSGallery -Confirm:$false
                  Import-Module -Name $module -Force
                  Write-Host "✓ Module $module installed successfully"
              } catch {
                  Write-Warning "Failed to install $module : $_"
              }
          }
        pwsh: true
        errorActionPreference: 'continue'

    # Step 4: Smart File Discovery and Deployment
    - task: PowerShell@2
      displayName: 'Smart File Discovery and Deployment'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "=== SMART FILE DISCOVERY AND DEPLOYMENT ==="
          Write-Host "Build Sources Directory: $(Build.SourcesDirectory)"
          Write-Host "Deployment Environment: $(deployment_env)"
          
          # Function to find files
          function Find-File {
              param($FileName, $SearchPath)
              
              Write-Host "`nSearching for: $FileName"
              $found = Get-ChildItem -Path $SearchPath -Recurse -Filter $FileName -ErrorAction SilentlyContinue | Select-Object -First 1
              
              if ($found) {
                  Write-Host "✅ Found: $($found.FullName)"
                  return $found.FullName
              } else {
                  Write-Host "❌ Not found: $FileName"
                  return $null
              }
          }
          
          # Search for required files
          $buildDir = "$(Build.SourcesDirectory)"
          $scriptPath = Find-File "MainOrchestrator.ps1" $buildDir
          $configPath = Find-File "config.json" $buildDir
          
          # Alternative search patterns
          if (-not $scriptPath) {
              Write-Host "`nTrying alternative script names..."
              $alternativeScripts = @("*.ps1")
              foreach ($pattern in $alternativeScripts) {
                  $found = Get-ChildItem -Path $buildDir -Recurse -Filter $pattern -ErrorAction SilentlyContinue | Where-Object { $_.Name -like "*orchestrat*" -or $_.Name -like "*deploy*" -or $_.Name -like "*main*" }
                  if ($found) {
                      $scriptPath = $found[0].FullName
                      Write-Host "✅ Found alternative script: $scriptPath"
                      break
                  }
              }
          }
          
          # Check if we have the minimum required files
          if (-not $scriptPath) {
              Write-Host "❌ No PowerShell deployment script found!"
              Write-Host "`n=== AVAILABLE FILES ==="
              Get-ChildItem -Path $buildDir -Recurse -Filter "*.ps1" | ForEach-Object { Write-Host "PS1 File: $($_.FullName)" }
              Get-ChildItem -Path $buildDir -Recurse -Filter "*.json" | ForEach-Object { Write-Host "JSON File: $($_.FullName)" }
              
              # Create a simple deployment script inline
              Write-Host "`n=== CREATING INLINE DEPLOYMENT SCRIPT ==="
              $inlineScript = @'
          param(
              [string]$Workspace = "Dev",
              [string]$ConfigFile
          )
          
          Write-Host "=== INLINE POWER BI DEPLOYMENT SCRIPT ==="
          Write-Host "Workspace: $Workspace"
          Write-Host "Config File: $ConfigFile"
          
          try {
              # Install and import PowerBI module if not available
              if (-not (Get-Module -Name MicrosoftPowerBIMgmt -ListAvailable)) {
                  Install-Module -Name MicrosoftPowerBIMgmt -Force -AllowClobber -Scope CurrentUser
              }
              Import-Module MicrosoftPowerBIMgmt -Force
              
              # Read config
              if (Test-Path $ConfigFile) {
                  $config = Get-Content $ConfigFile | ConvertFrom-Json
                  Write-Host "✅ Config loaded successfully"
                  
                  # Display config (without sensitive data)
                  Write-Host "Tenant ID: $($config.TenantID)"
                  Write-Host "Client ID: $($config.ClientID)"
                  Write-Host "Dev Workspace ID: $($config.DevWorkspaceID)"
                  Write-Host "UAT Workspace ID: $($config.UATWorkspaceID)"
              } else {
                  throw "Config file not found: $ConfigFile"
              }
              
              # Look for PBIX files
              $pbixFiles = Get-ChildItem -Path "$(Build.SourcesDirectory)" -Recurse -Filter "*.pbix" -ErrorAction SilentlyContinue
              Write-Host "`nFound $($pbixFiles.Count) PBIX files:"
              foreach ($file in $pbixFiles) {
                  Write-Host "  - $($file.FullName)"
              }
              
              if ($pbixFiles.Count -eq 0) {
                  Write-Warning "No PBIX files found. Looking for PBIP files..."
                  $pbipFiles = Get-ChildItem -Path "$(Build.SourcesDirectory)" -Recurse -Filter "*.pbip" -ErrorAction SilentlyContinue
                  Write-Host "Found $($pbipFiles.Count) PBIP files:"
                  foreach ($file in $pbipFiles) {
                      Write-Host "  - $($file.FullName)"
                  }
              }
              
              # Try to connect to Power BI (this will show if credentials work)
              Write-Host "`nTesting Power BI connection..."
              $securePassword = ConvertTo-SecureString $config.ClientSecret -AsPlainText -Force
              $credential = New-Object System.Management.Automation.PSCredential ($config.ClientID, $securePassword)
              
              Connect-PowerBIServiceAccount -ServicePrincipal -TenantId $config.TenantID -Credential $credential
              Write-Host "✅ Successfully connected to Power BI Service"
              
              # List workspaces
              $workspaces = Get-PowerBIWorkspace -All
              Write-Host "`nFound $($workspaces.Count) workspaces"
              
              # Find target workspace
              $targetWorkspaceId = if ($Workspace -eq "Dev") { $config.DevWorkspaceID } else { $config.UATWorkspaceID }
              $targetWorkspace = $workspaces | Where-Object { $_.Id -eq $targetWorkspaceId }
              
              if ($targetWorkspace) {
                  Write-Host "✅ Found target workspace: $($targetWorkspace.Name) (ID: $($targetWorkspace.Id))"
              } else {
                  Write-Warning "❌ Target workspace not found for environment: $Workspace"
              }
              
              Write-Host "`n✅ Deployment script validation completed successfully!"
              
          } catch {
              Write-Error "❌ Deployment failed: $_"
              throw
          }
          '@
              
              # Execute inline script
              $configPath = if ($configPath) { $configPath } else { "$(Build.SourcesDirectory)\config.json" }
              Invoke-Expression $inlineScript
              
              return
          }
          
          if (-not $configPath) {
              Write-Error "❌ No config.json file found!"
              return
          }
          
          # Execute the found script
          Write-Host "`n=== EXECUTING DEPLOYMENT SCRIPT ==="
          Write-Host "Script: $scriptPath"
          Write-Host "Config: $configPath"
          
          try {
              $scriptDir = Split-Path $scriptPath -Parent
              Set-Location $scriptDir
              
              & $scriptPath -Workspace "$(deployment_env)" -ConfigFile $configPath
              Write-Host "✅ Deployment completed successfully!"
              
          } catch {
              Write-Error "❌ Deployment failed: $_"
              throw
          }
        pwsh: true
        errorActionPreference: 'continue'  # Continue on errors

    # Step 4: Run the PowerShell script to convert PBIP to PBIX and deploy the reports
    - task: PowerShell@2
      displayName: 'Run PowerShell Script to Deploy Reports'
      inputs:
        targetType: 'filePath'
        filePath: '$(Build.SourcesDirectory)/Visa/Scripts/MainOrchestrator.ps1'  # Updated path
        arguments: '-Workspace $(deployment_env) -ConfigFile $(Build.SourcesDirectory)/$(config_file)'  # Pass environment and config file as parameters
        pwsh: true  # Use PowerShell Core (pwsh)
        workingDirectory: '$(Build.SourcesDirectory)'  # Set the script working directory to root of the repository
        errorActionPreference: 'stop'  # Stop on errors for the main script

    # Step 5: Publish build artifacts (optional step, if you want to store outputs like PBIX files)
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Artifacts'
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)'
        ArtifactName: 'drop'
        publishLocation: 'Container'